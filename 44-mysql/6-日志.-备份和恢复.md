# 日志

## 日志分类

MySQL 日志详解

| **日志类型**   | **用途**                                          | **默认位置/配置**                                            | **常用参数**                                                 | **注意事项**                       |
| -------------- | ------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------- |
| **错误日志**   | 记录MySQL启动、停止和运行中的错误信息。           | `log_error`参数指定路径，默认在数据目录下，如`/var/log/mysql/error.log`。 | `log_error` - 指定日志文件路径。                             | 重要的系统和运行错误会记录在此。   |
| **查询日志**   | 记录所有查询语句和客户端操作，便于调试。          | `general_log_file`参数指定路径，如`/var/log/mysql/general.log`。 | `general_log` - 是否启用；`general_log_file` - 指定日志文件路径。 | 性能影响较大，生产环境慎用。       |
| **慢查询日志** | 记录执行时间超过指定阈值的SQL语句，用于性能优化。 | `slow_query_log_file`参数指定路径，如`/var/log/mysql/slow.log`。 | `long_query_time` - 慢查询时间；`log_queries_not_using_indexes` - 是否记录未用索引的查询。 | 配置合理的时间阈值，避免日志过大。 |
| **二进制日志** | 记录所有数据修改的SQL，用于恢复和主从复制。       | `log_bin`参数指定路径，如`/var/log/mysql/mysql-bin`。        | `binlog_format` - 日志格式（STATEMENT、ROW、MIXED）。        | 使用`mysqlbinlog`工具查看内容。    |
| **事务日志**   | 记录InnoDB事务操作和崩溃恢复信息。                | 默认文件名为`ib_logfile0`和`ib_logfile1`，位于数据目录中。   | `innodb_log_file_size` - 日志文件大小；`innodb_log_files_in_group` - 日志文件数量。 | 日志大小影响性能，需合理配置。     |
| **中继日志**   | 用于主从复制，存储从主服务器接收的事件。          | `relay_log`参数指定路径，默认在数据目录中。                  | `relay_log_purge` - 是否清理已处理的日志；`relay_log` - 指定中继日志路径。 | 定期清理避免磁盘占用过多。         |
| **审计日志**   | 记录用户活动和SQL语句，主要用于安全审计。         | 需安装审计插件，路径由插件配置，如`audit_log_file`参数。     | `audit_log_policy` - 配置审计策略；                          | 安全需求高的环境使用，需插件支持。 |

日志管理最佳实践

1. **限制日志大小**：配置合理的日志文件大小和轮转。
2. **选择性启用**：根据需求启用相关日志类型，避免性能下降。
3. **定期清理或归档**：使用 `logrotate` 等工具。
4. **监控和分析**：结合工具如 pt-query-digest、mysqlbinlog 进行分析。

    *   **pt-query-digest**：分析慢查询日志。

    *   **mysqlbinlog**：解析二进制日志。

## 事务日志

事务有4种特性：原子性、一致性、隔离性和持久性，那么事务的四种特性到底是基于什么机制实现的

- 事务的隔离性由`锁机制`实现
- 而事务的原子性、一致性和持久性由事务的redo日志和undo日志来保证
    - REDO LOG 称为`重做日志`，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性
    - UNDO LOG 称为`回滚日志`，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。


有的DBA或许会认为UNDO是REDO的逆过程，其实不然，REDO和UNDO都可以视为一种`恢复操作`，但是：

- redo log：是存储引擎层（innodb）生成的日志，记录的是`物理级别`上的页修改操作，比如页号XXX，偏移量YYY写入了ZZZ数据，主要为了保证数据的可靠性

- undo log：是存储引擎(innodb)生成的日志，记录的是`逻辑操作日志`，比如某一行数据进行了INSESRT语句操作，那么undo log就记录一条与之相反的DELETE操作。主要用于`事务回滚`（undo log记录的是每个修改操作的`逆操作`）和`一致性非锁定读`（undo log回滚行记录到某种特定的版本...MVCC,即多版本并发控制）。

### redo log 重做日志

**Redo Log 的作用**

**事务的持久性**：+

-   当事务提交时，数据可能尚未写入到磁盘的表文件中。Redo Log 确保事务的修改记录在磁盘中，即使数据库崩溃也能恢复。

**崩溃恢复**：

-   在系统崩溃后，InnoDB 使用 Redo Log 重新执行已提交但未写入表文件的事务，恢复数据库到一致的状态。

**优化磁盘 I/O**：

-   数据页的更新操作通常是随机 I/O，而日志的写入是顺序 I/O。InnoDB 优先将修改记录写入日志，再以异步方式刷新数据页到磁盘，从而提高性能。



redo log跟bin log的区别，redo log是`存储引擎层`产生的，而bin log是`数据库层`产生的。

假设一个事务，对表做10万行的记录插入，在这个过程中，一直不断的往redo log顺序记录，而bin log不会记录，直到这个事务提交，才会一次写入到bin log文件中



#### redo的组成

Redo log可以简单的分为以下两个部分

- 重做日志的缓冲(redo log fauther)，保存在内存中，是易失的。
    - 在服务器启动时就向系统申请了一大片称之为redo log buffer的`连续内存`空间，翻译成中文就是redo日志缓冲区。这片内存空间被划分为若干个连续的`redo log block`。一个redo log block占用`512字节`大小
- 重做日志文件(redo log file)，保存在硬盘中，是持久的
    - REDO日志文件，其中的`ib_logfile0`和`ib_logfile1`即为REDO日志

#### Redo Log 的工作机制

1.   **事务开始**
2.   **读取数据**
3.   

#### 配置信息

要更改的话，需要在配置文件中更改。

```sql
SHOW VARIABLES LIKE '%innodb_log%';
+------------------------------------+----------+
| Variable_name                      | Value    |
+------------------------------------+----------+
| innodb_log_buffer_size             | 16777216 | # 缓冲大小
| innodb_log_checksums               | ON       |
| innodb_log_compressed_pages        | ON       |
| innodb_log_file_size               | 50331648 | # 每个事务日志文件大小
| innodb_log_files_in_group          | 2        | # 事务日志文件个数
| innodb_log_group_home_dir          | ./       | # 日志所在位置
| innodb_log_spin_cpu_abs_lwm        | 80       |
| innodb_log_spin_cpu_pct_hwm        | 50       |
| innodb_log_wait_for_flush_spin_hwm | 400      |
| innodb_log_write_ahead_size        | 8192     |
| innodb_log_writer_threads          | ON       |
+------------------------------------+----------+
11 rows in set (0.00 sec)

# mysql8.0独有
# 设置 InnoDB 重做日志的总容量。
# 当定义了innodb_redo_log_capacity设置时，
# 将忽略innodb_log_files_in_group, innodb_log_file_size设置
show variables like '%innodb_redo_log_capacity%';
+--------------------------+-----------+
| Variable_name            | Value     |
+--------------------------+-----------+
| innodb_redo_log_capacity | 104857600 |
+--------------------------+-----------+
1 row in set (0.01 sec)
-- 此设置的redo log放置在工作目录的'#innodb_redo'目录下
-- 共32个redo文件

# 工作目录
show variables like '%datadir%';
+---------------+-----------------+
| Variable_name | Value           |
+---------------+-----------------+
| datadir       | /var/lib/mysql/ |
+---------------+-----------------+
1 row in set (0.00 sec)

# redo日志刷盘相关
mysql> SHOW VARIABLES LIKE '%innodb_flush%';
+--------------------------------+-------+
| Variable_name                  | Value |
+--------------------------------+-------+
| innodb_flush_log_at_timeout    | 1     | # 最大超时时间，日志文件的写入时间超过该超时时间，InnoDB 会强制刷新日志。
| innodb_flush_log_at_trx_commit | 1     | # 刷新策略，默认是1
| innodb_flush_method            | fsync | # 如何刷新日志到磁盘
| innodb_flush_neighbors         | 0     | # 控制是否优化相邻数据页的刷新。
| innodb_flush_sync              | ON    | # 是否同步 InnoDB 的 I/O 操作。
| innodb_flushing_avg_loops      | 30    | # 
+--------------------------------+-------+
6 rows in set (0.00 sec)
```

#### 

### undo log 回滚日志



# MySQL备份和恢复